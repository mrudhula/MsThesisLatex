\appendix
\chapter{OGRE Framework}
\label{appendix_ogre_framework}

As a programmer, I embrace the do not repeat yourself mindset and extreme programming methodology. Furthermore, since my study required utilization of many different techniques in different fields in Computer Science, I searched for various third party Software Development Kids (SDKs) to save me from writing ground-level code. These two beliefs led me to search for the rendering engine best suited for my needs:

\begin{enumerate}
\item must be code-oriented rather than designer-oriented;
\item must be able to utilize both DirectX and OpenGL (for compatibility reasons);
\item must take care of mundane and routine programming such as the rendering pipeline and input handling;
\item must be able to integrate easily with 3rd party libraries;
\item must be stable and mature;
\item must have an associated 3-D designing program which can be used to easily produce content and load into the program; and
\item must have accurate and extensive documentation.
\end{enumerate}

Other than these, automatic material rendering, skeletal animation support were considered as bonuses.
After experimenting with Unity, UDK and native OpenGL programming, I eventually decided on Object-Oriented Rendering Engine (will be referred as OGRE in the rest of the paper) for it complies with my requirements the best.


\section{The Features}
Unlike the name suggests, OGRE is more than just a rendering engine. Among all the features, the ones I utilized are as follows~\cite{Knot2012}.

\begin{itemize}
\item Render state management.
\item Spatial culling and transparency handling.
\item Material rendering:
\begin{itemize}
  \item easy material and shader management, custom shader support,
  \item multitexture and multipass blending,
  \item lighting shader and different shadow rendering techniques,
  \item material level of detail support,
  \item support for a variety of image formats, volumetric textures and DXT textures, and
  \item render-to-texture (frame rendering buffer) support.
\end{itemize}
\item Meshes:
\begin{itemize}
  \item native mesh format, which can be exported from Blender Designer,
  \item level of detail support,
  \item skeletal animation feature, can be used with models exported from Blender:
\begin{itemize}
  \item multiple-bone weighted skinning
  \item hardware acceleration.
\end{itemize}
\end{itemize}
\item Easy scene management.
\item Easy camera and input management.
\item Easy integration with third party libraries due to code-based nature.
\item Overlay feature which enables easy information tracking about the feature.
\end{itemize}

These features led me to choose OGRE as my base framework.

\section{High Level Overview}
Figure \ref{fig:ogre-class-diagram} shows the class diagram for the object-oriented core of OGRE~\cite{Moan2012}:

\begin{figure}[h]
\centerline{\fbox{\psfig{figure=figures/ogre_class_diagram.eps,width=1.0\textwidth}}}
\caption{Overview of the OGRE framework}
\label{fig:ogre-class-diagram}
\end{figure}

\subsection{The Root object}
The root object is the entry point and core of the framework.
\begin{itemize}
\item It is created first and destroyed last in the application lifecycle. 
\item It configures the system, delivers pointers to the managers for various resources.
\item Provides automatic rendering cycle, continued until an interrupt from FrameListener objects.
\end{itemize}

\subsection{The RenderSystem Object}
Render system is an abstract class to define the underlying 3D API (either Direct 3D or OpenGL). This class is not accessed and modified by the application programmer.

\subsection{The SceneManager Object}
SceneManager is the most used object by the application programmer, as it is in charge of the contents in the scene to be rendered.
\begin{itemize}
\item It is used to create, destroy and update the objects.
\item It sends the scene to the RenderSystem behind the curtains for rendering.
\item Multiple SceneManagers can be used to create other visual resources (ex. RenderToTexture environment)
\end{itemize}

\subsection{Resource Manager}
ReosurceManager object is an abstract class, used to create, keep and dispatch a type of resource it is associated with. 
\begin{itemize}
\item The associated type is defined by the class inheriting the ResourceManager, such as MaterialManager.
\item There is always only one instance of every child of ReosurceManager in an application.
\item Resource managers search the pre-defined locations of the filesystem and automatically indexes the resources available, ready to be loaded upon demand.
\end{itemize}


\subsection{Entities, Meshes, Materials and Overlays}
Entities are the instances of movable objects in the scene. They are based on meshes, which define the geometric and material properties of the entity. Materials contain information about what color the final pixel in the rendering should be. 
\begin{itemize}
\item Entities are attached to scene nodes for moving and rendering. Scene nodes can be nested, which greatly simplifies the process of rendering complex scenes.
\item Meshes consist of submeshes, which can have different material associations. Therefore, a mesh can be composed of various parts with various materials.
\item Materials are defined either in run-time or in .material scripts, with detailed information. They also support custom shaders.
\item Mesh files can be created and saved with manual objects, or exported through designer programs such as Blender. The .mesh files are in binary format.
\end{itemize}
Overlays are used to create panels for control and HUD which are rendered above the scene. They are 2D elements are placed either by screen proportion or pixel size and rendered orthographically, last in the rendering pipeline by default (this can be overridden).

\subsection{The Rendering Cycle}
The self-explanatory rendering cycle of OGRE is given in Figure \ref{fig:ogre-render-cycle}~\cite{Moan2012}.

\begin{figure}[h]
\centerline{\fbox{\psfig{figure=figures/ogre_render_cycle.eps,width=1.0\textwidth}}}
\caption{OGRE rendering cycle}
\label{fig:ogre-render-cycle}
\end{figure}
 