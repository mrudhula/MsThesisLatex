\chapter{Cloth Simulation}
\label{chapter6}

For the cloth simulation, I utilized the Nvidia PhysX engine, which provides cloth simulation framework along with collision detection. 

\section{Model Set Up}
The mesh to be simulated is the bottom part of the modeled dress which consists of 3100 vertices. It is aligned precisely with the top part and the female body to be simulated realistically. 

I needed to provide the PhysX framework with the vertex and topology information separately, instead of a binary file or an automatic parser. I implemented a Wavefront OBJ file parser myself to acquire the information exported from a modeling suite, and feed the data into the physics engine. 

Other than the vertex and topology information, an inverse weight needs to be specified for every vertex.  This information can be embedded into the wavefront object as a second set of texture coordinates. On the other hand, this method adds too much extra data to the file, which is not a major problem, although not necessary. Therefore I chose to embed this information into the model, by specifying the material names separately for vertex groups with different weights. 

The vertices which have a non-zero inverse weight have the suffix �Free� attached to their material name. The vertices are selected manually and their materials are attached. The current simulation required only two set of weights, which can be seen in Figure \ref{fig:cloth_fixed_vertices}. After the weight information is implemented, the model is exported as a Wavefront OBJ file along with the MTL, and parsed into the software.

\begin{figure}[h]
\centerline{\fbox{\psfig{figure=figures/cloth_fixed_vertices.png,width=1.00\textwidth}}}
\caption{The fixed vertices of the cloth}
\label{fig:cloth_fixed_vertices}
\end{figure}

\section{The Initialization}

After the model is parsed from the OBJ file, it is stored into C++ vectors initially, to be used in different frames. First, the OBJ file is converted into the Ogre native mesh format to be loaded and rendered. This simply includes feeding the vertex, topology and material information into the ogre as submeshes, to be combined as a mesh.
Prior to creating the simulated cloth the PhysX engine needs to be initialized:

\begin{enumerate}
\item The foundation and the SDK objects are created.
\item In order to implement the GPU solver for the cloth and collision, the PhysX engine needs to bind with the CUDA context to deliver the GPU tasks. The CUDA Context manager object is created and given to the SDK object.
\item Afterwards, the virtual floor and the environment are created with the gravity specified as 9.8 m/s2. 
\end{enumerate}

After the initialization, the cloth is loaded with specific stiffness, stretch, damping, friction, inertia, bending, and collision parameters. These parameters are decided after numerous experimentations in order to acquire the most realistic simulation results.
After creating the environment and the virtual cloth, the collision spheres are created, which will be explained in chapter \ref{chapter7}.

\section{The Animation}
Each frame, the workflow is as following:
\begin{enumerate}
\item The passed time since the last frame is added to the counter.
\item The Kinect Sensor is checked for new data. If the data is not new, next frame is called. 
\item If there is an active user with the Kinect, the userID is set into the female body and the upper cloth meshes to be updated. If there are none, the bones are reset to their initial state.
\item The upper body mesh and the female body mesh are ordered to be updated. The update details can be found in chapter \ref{section5_2}. This function returns the translation of the root node. 
\item The returned vector from step 4 is used to translate the lower cloth handle. After the translation, the orientation is also updated with the root bone orientation.
\item The colliding human capsules are updated with the female body bone orientation. Also, the orientation and the position of the lower cloth handle is synchronized with the virtual cloth. This input automatically introduces the inertia effect on the cloth.
\item In the end, the cloth is simulated as following:
\begin{enumerate}
  \item PhysX is ordered to start the simulation on the GPU. Simulation algorithm details are explained in section \ref{section6_4}.
  \item The vertex data is read from the output, and the vectors of the OBJ object are updated, except the fixed mesh vertices. The reason for omitting the fixed vertices is to avoid unnatural bends and cracks on the fixed vertices.
  \item The updated OBJ vectors are transformed into the Ogre Mesh buffers, to be rendered. 
\end{enumerate}
\end{enumerate}

\section{The Algorithm}
\label{section6_4}

The cloth simulation algorithm is based on the Position Based Dynamics, introduced by M�ller et al. \cite{Muller2007}. The main idea is to calculate the position of the particles from their previous positions and applying constraints on mutual distance and angle. The collision is also calculated as a force and applied to both particles. The approach is stable and efficient for real time applications.

The dynamics are stable as long as the constraint solvers converge. When this criteria is not met, anomalies show up, such as when a vertex is pulled too far away from the cloth. 

The problem is parallelized by fibers, as SIMD process. With CUDA support, however, this is even parallelized more with SIMT processes, where each thread works on one fiber

\subsection{Overall Structure}
The position of a particle in the next time interval is acquired by performing
Explicit Euler Integration over $\delta$t, where the velocity and the force are
assumed to be constant during the interval. The pseudo code is given  in
Algorithm \ref{algo:position_based_dynamics}.

\begin{algorithm}
\dontprintsemicolon % Some LaTeX compilers require you to use \dontprintsemicolon instead
\ForEach {vertices i}{
$initialize$ $x_i=x_i^0,v_i=v_i^0,w_i=1/m_i$
}
\While{true}{
\ForEach {vertices i}{$v_i \gets v_i + \Delta t w_i f_{ext}(x_i)$}
dampVelocities($v_1,\ldots.,v_N$)\;
\ForEach {vertices i}{$p_i \gets x_i + \Delta t v_i $\;}
\ForEach {vertices i}{$generateCollisionConstraints(x_i \to p_i)$}
\While{solverIterates}{$projectConstraints(C_1,\ldots,C_{M+M_{coll}},p_1,\ldots,p_N)$}
\ForEach {vertices i}{
$v_i \gets (p_i - x_i) / \Delta t$\;
$x_i \gets p_i $\;
}
$velocityUpdate(v_1,\ldots,v_N)$\;
}
\caption{Position Based Dynamics}
\label{algo:position_based_dynamics}
\end{algorithm}

The overall flow is to predict the next position and velocity (1-2), then
perform the corrections by solving the constraints (3-12), update the position
and velocities accordingly (13:15). Finally, the damping to the velocities is
introduced in line 16.

The key issue in the simulation is the position correction due to the constraints. Each vertex is moved either towards or away from each other, the distance is scaled by the inverse mass of the vertices. If a vertex position needs to be fixed, the inverse weight should be set to zero

\subsection{Constraints, Fibers and Sets}
In order to simulate the cloth, all constraints should be solved, which is achieved through linearizing the non-linear problem. This linearization results in a sparse matrix problem. Although the problem is solvable in real-time, performance is increased further by pivoting vertical and horizontal constraints, solving separately. The vertical and horizontal constraints are divided in the input sense by fibers and sets. Fibers represent independent sets of connected constraints and sets are non-overlapping fibers, which are solved in parallel. In the implementation and mesh terms, a fiber is either a horizontal, vertical or a diagonal line, and the set is the collection of parallel lines. These fibers and sets are generated for both shear and stretch constraints by the PhysX mesh cooker, which auto-generates the fibers and sets from a given mesh topology (Figure \ref{fig:shear_strech_sets}). 

\begin{figure}[h]
\centerline{\fbox{\psfig{figure=figures/shear_strech_sets.png,width=1.00\textwidth}}}
\caption{Shear and Scretch Sets. The red and yellow lines are the fibers \cite{Kim2011}}
\label{fig:shear_strech_sets}
\end{figure}

\subsection{Set Solvers}
There are two possible solvers to apply on fiber block(Set) which come with PhysX:
\begin{itemize}
  \item The Gauss-Seidel solver continues along the fiber after completing a constraint solution and updating the results. This solver is easy to tweak and user, has low-cost for iteration, however the convergence factor is low due to sequential update, which results in a stretchy cloth.
  \item Semi-Implicit solver factorizes the tri-diagonal system with LDLT and solves the overall system. This method preserves momentum since it is not sequential and converges ten times more than Gauss-Seidel solver. However, the matrices can be ill conditioned, which requires special treatment, iteration cost is higher and tweaking is more difficult.
\end{itemize}
The comparison of these solvers can be seen in Figure \ref{fig:solver_comparison}. In order to get the best performance from these solvers, they are applied on different Sets, taking advantage of them being solvable in parallel. Gauss-Seidel solver is used for horizontal stretch fibers and the shear fibers, which do not experience too much stretching, taking advantage of its low cost. Semi implicit solver is applied only to the vertical stretch fibers, which put up with most of the force (gravity) most of the time, resulting in a both fast and robust solution

\begin{figure}[h]
\centerline{\fbox{\psfig{figure=figures/solver_comparison.png,width=0.50\textwidth}}}
\caption{Comparison of Gauss-Seidel and Semi-Implicit Solvers \cite{Kim2011}}
\label{fig:solver_comparison}
\end{figure}


